# Оптимізація у React

Оптимізація в `React` допомагає підвищити продуктивність програми шляхом зменшення навантаження на ресурси. Це може бути досягнуто за допомогою таких методів, як мемоізація, ліниве завантаження компонентів, оптимізація рендерингу, використання React.memo та інших підходів. Правильно оптимізований `React` додаток буде швидше працювати та забезпечувати кращий користувацький досвід.


## React.memo

`React.memo` - це вбудована функція в бібліотеці `React`, яка дозволяє оптимізувати рендеринг компонентів шляхом запам'ятовування результатів попередніх рендерів. Це особливо корисно при роботі з функціональними компонентами, які повертають те ж значення при однакових пропсах. Використання `React.memo` допомагає уникнути зайвого рендерингу компонентів, які не змінили свій стан або пропси.

Отже, для використання `React.memo` потрібно обгорнути компонент за допомогою цієї функції. Наприклад:

```
import React from 'react';

const Component = React.memo((props) => {
    return <div>{props.text}</div>;
});

export default Component;
```

У цьому прикладі компонент `Component` буде запам'ятовувати свій рендер, якщо `prop` "text" залишається незмінним. Це дозволяє уникнути зайвого рендерингу у випадках, коли prop "text" не змінився.

**React.memo** — це потужний інструмент для мемоізації функціональних компонентів в `React`. Однак, як і будь-який інструмент, він має свої обмеження та недоліки. Давайте розглянемо їх:

1. **Зайві перевірки пропсів**: Якщо ваш компонент постійно перерендерюється з пропсами, які в будь-якому випадку змінюються, `React.memo` виконує непотрібну поверхневу перевірку пропсів кожного разу. Якщо компонент завжди перерендерюється, `React.memo` не зможе запобігти перерендеру, але при цьому він виконує додаткові обчислення.
2. **Вартість мемоізації**: Якщо ваш функціональний компонент теоретично повинен перерендерюватися лише 5% часу, вартість одного перерендеру може бути незначною порівняно з витратами на мемоізацію.
3. **Функції порівняння**: React.memo використовує поверхневу перевірку пропсів за допомогою функції порівняння. Якщо ця функція обчислюється дорого, це може вплинути на продуктивність. \
4. **Колбеки в пропсах**: Якщо ваш компонент використовує пропси як колбеки, будьте обережні. Переконайтеся, що ви передаєте той самий екземпляр функції між рендерингами, щоб уникнути непотрібних перерендерів. \


## useCallback

Різні функції, що використовують один код, часто створюються всередині компонентів React:
```
function Component() {
  // handleClick is re-created on each render
  const handleClick = () => {
    console.log('Clicked!');
  };
  // ...
}
```
`handleClick` є різним функціональним об’єктом для кожного рендеру `Component`.

Оскільки вбудовані функції дешеві, повторне створення функцій під час кожного рендеру не є проблемою.
Але в деяких випадках вам потрібно мати єдиний екземпляр функції між рендерами:

1. Функціональний компонент, загорнутий у `React.memo()`, приймає об’єкт функції як проп
2. Коли об’єкт функції є залежністю від інших хуків, наприклад `useEffect(..., [callback])`
3. Коли функція має певний внутрішній стан `(debounce, throttle)`.

Наприклад,у нас є компонент `<List>`, який відображає великий список елементів:
```
function List({ term, onItemClick }) {
  const items = useSearch(term);

  return (
    <div>
      {items.map(item =>
        (<div key={item} onClick={onItemClick}>{item}</div>)
      }
    </div>);
}

export default React.memo(List);
```

Список може бути великим, можливо, сотні пунктів. Щоб запобігти непотрібному повторному рендеру списку, ми загортаємо його в `React.memo()`.

Батьківський компонент надає функцію обробки, щоб знати, коли натиснуто елемент:
```
import { useCallback } from 'react';

export function Parent({ term }) {
  const onItemClick = useCallback(event => {
    console.log('You clicked ', event.currentTarget);
  }, []);

  return (
    <List
      term={term}
      onItemClick={onItemClick}
    />
  );
}
```

Коли `Parent` компонент повторно рендериться, `onItemClick` залишається незмінним і не порушує мемоїзацію.

Це був хороший варіант використання `useCallback`.

Давайте розглянемо інший приклад:
```
import { useCallback } from 'react';

function Component() {
  const handleClick = useCallback(() => {
    console.log('You clicked');
  }, []);

  return <Child onClick={handleClick} />;
}

function Child ({ onClick }) {
  return <button onClick={onClick}>I am a child</button>;
}
```
Проблема полягає в тому, що `useCallback` хук викликається кожного разу під час рендеру.

Чи варто використовувати `useCallback`? Швидше за все, ні тому, що `<Child>` компонент легкий, і його повторний рендеринг не створює проблем з продуктивністю. Оптимізація коштує дорожче, ніж відсутність оптимізації .
